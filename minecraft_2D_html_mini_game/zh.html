<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <!-- 禁止縮放，提升觸控體驗 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Minecraft 2D 探險版</title>
  <style>
    /* 遊戲開始介面 */
    #startScreen {
      position: fixed; 
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: #7CFC00;
      z-index: 200;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #startScreen h1 { 
      font-size: 72px; 
      margin: 0; 
      color: #000; 
    }
    #startScreen button {
      font-size: 24px;
      padding: 10px 20px;
      margin-top: 20px;
      border: none;
      border-radius: 5px;
      background-color: #fff;
      cursor: pointer;
    }
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
      touch-action: manipulation;
      user-select: none;
    }
    canvas { 
      display: block; 
    }
    .top-controls {
      position: fixed; 
      top: 10px; left: 10px; 
      z-index: 10;
    }
    .top-controls button {
      font-size: 16px; 
      padding: 5px 10px; 
      margin-right: 5px;
      border: none; 
      border-radius: 5px; 
      background-color: #fff;
      user-select: none;
      touch-action: none;
    }
    /* 方塊素材庫存 */
    #inventoryUI {
      position: fixed; 
      top: 60px; left: 50%;
      transform: translateX(-50%);
      display: flex; gap: 5px; 
      z-index: 10;
    }
    #inventoryUI button {
      width: 50px; height: 50px;
      border: 2px solid #000;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    /* 合成後的物品庫存 */
    #iteminventory {
      position: fixed; 
      top: 120px; left: 50%;
      transform: translateX(-50%);
      display: flex; gap: 5px; 
      z-index: 10;
    }
    #iteminventory button {
      width: 50px; height: 50px;
      border: 2px solid #000;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    /* 血量顯示 */
    #hpDisplay {
      position: fixed; 
      top: 10px; right: 10px;
      font-size: 20px;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 10;
    }
    /* 左下控制區 */
    #leftControls {
      position: fixed; 
      bottom: 10px; left: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    /* 右下控制區 */
    #rightControls {
      position: fixed; 
      bottom: 10px; right: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
    }
    .control-group { 
      display: flex; 
      gap: 8px; 
    }
    #leftControls button,
    #rightControls button {
      font-size: 18px;
      padding: 10px;
      border: none;
      border-radius: 5px;
      background-color: #fff;
      user-select: none;
      touch-action: none;
    }
    /* 死亡畫面 */
    #deathScreen {
      position: fixed; 
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(255,0,0,0.9);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 40px;
      z-index: 100;
      display: none;
    }
    #deathScreen button {
      font-size: 24px;
      padding: 10px 20px;
      margin-top: 20px;
    }
    /* 合成介面 */
    #craftingScreen {
      position: fixed; 
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: #D2B48C;
      z-index: 100;
      display: none;
      overflow-y: auto;
      padding: 20px;
    }
    #craftingScreen h2 { 
      margin-top: 0; 
    }
    #craftingOptions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    #craftingOptions button {
      width: calc(25% - 10px);
      min-width: 80px;
      padding: 10px;
      border: 2px solid #000;
      border-radius: 5px;
      background-color: #fff;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    #craftingScreen button.closeBtn {
      margin-top: 20px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <!-- 遊戲開始介面：選擇探險模式或和平模式 -->
  <div id="startScreen">
    <h1>Minecraft 2D 探險版</h1>
    <button onclick="startAdventure();">探險模式</button>
    <button onclick="startPeaceful();">和平模式</button>
  </div>
  
  <!-- 遊戲畫布 -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- 左上控制區 -->
  <div class="top-controls">
    <button onclick="goToHomePage(); event.preventDefault();">主頁面</button>
    <button onclick="openCrafting(); event.preventDefault();">合成</button>
  </div>
  
  <!-- 方塊素材庫存 -->
  <div id="inventoryUI"></div>
  <!-- 合成後的物品庫存 -->
  <div id="iteminventory"></div>
  <!-- 血量顯示 -->
  <div id="hpDisplay">HP: 10</div>
  
  <!-- 左下控制區：移動與破壞 -->
  <div id="leftControls">
    <div class="control-group">
      <button ontouchstart="moveLeft(); event.preventDefault();" ontouchend="stopMoving(); event.preventDefault();" onclick="moveLeft()">←</button>
      <button ontouchstart="moveRight(); event.preventDefault();" ontouchend="stopMoving(); event.preventDefault();" onclick="moveRight()">→</button>
    </div>
    <div class="control-group">
      <button ontouchstart="destroyBlockDir('up'); event.preventDefault();" onclick="destroyBlockDir('up')">破壞 上</button>
    </div>
    <div class="control-group">
      <button ontouchstart="destroyBlockDir('left'); event.preventDefault();" onclick="destroyBlockDir('left')">破壞 左</button>
      <button ontouchstart="destroyBlockDir('right'); event.preventDefault();" onclick="destroyBlockDir('right')">破壞 右</button>
    </div>
    <div class="control-group">
      <button ontouchstart="destroyBlockDir('down'); event.preventDefault();" onclick="destroyBlockDir('down')">破壞 下</button>
    </div>
  </div>
  
  <!-- 右下控制區：攻擊、跳躍、放置 -->
  <div id="rightControls">
    <div class="control-group">
      <button ontouchstart="playerAttack(); event.preventDefault();" onclick="playerAttack()">攻擊</button>
    </div>
    <div class="control-group">
      <button ontouchstart="jump(); event.preventDefault();" onclick="jump()">跳躍</button>
    </div>
    <div class="control-group">
      <button ontouchstart="placeBlockDir('up'); event.preventDefault();" onclick="placeBlockDir('up')">放置 上</button>
    </div>
    <div class="control-group">
      <button ontouchstart="placeBlockDir('left'); event.preventDefault();" onclick="placeBlockDir('left')">放置 左</button>
      <button ontouchstart="placeBlockDir('right'); event.preventDefault();" onclick="placeBlockDir('right')">放置 右</button>
    </div>
    <div class="control-group">
      <button ontouchstart="placeBlockDir('down'); event.preventDefault();" onclick="placeBlockDir('down')">放置 下</button>
    </div>
  </div>
  
  <!-- 死亡畫面 -->
  <div id="deathScreen">
    <div>你死了</div>
    <button onclick="restartGame(); event.preventDefault();">重新開始</button>
  </div>
  
  <!-- 合成介面 -->
  <div id="craftingScreen">
    <h2>合成介面</h2>
    <div id="craftingOptions"></div>
    <button class="closeBtn" onclick="closeCrafting()">關閉合成介面</button>
  </div>
  
  <script>
    // 防止 iOS 縮放手勢
    document.addEventListener("gesturestart", e => e.preventDefault());
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    /* —— 基本參數 —— */
    const tileSize = 40;
    const worldCols = 60;
    const groundLevel = 10;
    const mineralStart = 25;
    const lavaStart = 50;
    const worldRows = 70;
    const bedrockStart = 65;
    
    // 區域生成機率
    const caveChance = 0.3;
    const waterChance = 0.05;
    const oreChance = 0.2;
    const lavaChance = 0.25;
    const oreChanceDeep = 0.25;
    
    // 礦物種類（更新 iron 顏色為奶白色 #FFF8E1）
    const oreTypes = [
      { type: "coal", color: "#2F4F4F" },
      { type: "iron", color: "#FFF8E1" },
      { type: "gold", color: "#FFD700" },
      { type: "diamond", color: "#00FFFF" }
    ];
    
    // 物理參數
    const gravity = 0.5;
    const moveSpeed = 4;
    const jumpVelocity = -12;
    
    // 玩家屬性（【修正】空手設為 -1）
    const player = {
      x: tileSize * 2,
      y: (groundLevel - 1) * tileSize,
      width: tileSize,
      height: tileSize,
      vx: 0,
      vy: 0,
      onGround: false,
      health: 10,
      fallStartY: null,
      toolLevel: -1,
      injured: false,
      injuredTime: 0,
      waterStartTime: null,
      lastWaterDamageTime: null
    };
    
    // 玩家武器補正（武器傷害加成）
    let playerWeaponBonus = 0;
    
    let moveDirection = 0;
    let gameOver = false;
    let lastLavaDamageTime = Date.now();
    let lastVoidDamageTime = Date.now();
    
    // 全域集合：世界資料、怪物、投射物
    let worldData = [];
    let entities = [];
    let projectiles = [];
    
    /* —— 庫存與破壞設定 —— */
    let inventory = {};
    let itemInventory = {};
    // 更新工具需求：
    // "grass", "leaf", "wood", "ice"：需求 -1（空手可破壞）
    // "stone", "coal", "deepStone"：需求 0（必須擁有等級 0 或更高的工具，空手 -1 不能破壞）
    // "iron", "gold"：需求 1
    // "diamond"：需求 2
    // "bedrock" 永遠不可破壞
    const blockRequirements = {
      "grass": -1,
      "leaf": -1,
      "wood": -1,
      "ice": -1,
      "stone": 0,
      "coal": 0,
      "deepStone": 0,
      "iron": 1,
      "gold": 1,
      "diamond": 2,
      "bedrock": Infinity
    };
    const collectibleTypes = ["grass", "wood", "stone", "iron", "gold", "diamond", "coal"];
    
    // 遊戲模式設定
    let gameMode = "adventure"; // "adventure" 或 "peaceful"
    
    /* —— 合成配方 —— */
    const recipes = [
      { name: "木劍", materials: {"wood": 2}, isTool: true, toolLevel: 1, type: "sword" },
      { name: "木鎬", materials: {"wood": 3}, isTool: true, toolLevel: 0, type: "pickaxe" },
      { name: "石劍", materials: {"stone": 2}, isTool: true, toolLevel: 1, type: "sword" },
      { name: "石鎬", materials: {"stone": 3}, isTool: true, toolLevel: 1, type: "pickaxe" },
      { name: "鐵劍", materials: {"iron": 2}, isTool: true, toolLevel: 2, type: "sword" },
      { name: "鐵鎬", materials: {"iron": 3}, isTool: true, toolLevel: 2, type: "pickaxe" },
      { name: "黃金劍", materials: {"gold": 2}, isTool: true, toolLevel: 1, type: "sword" },
      { name: "黃金鎬", materials: {"gold": 3}, isTool: true, toolLevel: 0, type: "pickaxe" },
      { name: "鑽石劍", materials: {"diamond": 2}, isTool: true, toolLevel: 3, type: "sword" },
      { name: "鑽石鎬", materials: {"diamond": 3}, isTool: true, toolLevel: 3, type: "pickaxe" },
      { name: "火把", materials: {"coal": 1, "wood": 1}, isTool: false },
      { name: "鐵桶", materials: {"iron": 3}, isTool: true, type: "bucket" }
    ];
    
    /* —— 日夜交替 —— */
    let startTime = performance.now();
    let dayTime = 0;
    function updateBackground() {
      const elapsed = performance.now() - startTime;
      dayTime = (elapsed % 360000) / 360000 * 2 * Math.PI;
      let intensity = (Math.sin(dayTime) + 1) / 2;
      const r = Math.floor(20 + intensity * (135 - 20));
      const g = Math.floor(20 + intensity * (206 - 20));
      const b = Math.floor(40 + intensity * (235 - 40));
      document.body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    }
    function isNight() {
      let intensity = (Math.sin(dayTime) + 1) / 2;
      return intensity < 0.5;
    }
    
    /* —— 世界生成 —— */
    function generateWorld() {
      worldData = [];
      for (let row = 0; row < worldRows; row++) {
        for (let col = 0; col < worldCols; col++) {
          let x = col * tileSize;
          let y = row * tileSize;
          if (row < groundLevel)
            continue;
          else if (row === groundLevel) {
            worldData.push({ x: x, y: y, type: "grass", color: "#00FF00" });
            if (Math.random() < 0.2 && row - 1 >= 0) {
              worldData.push({ x: x, y: y - tileSize, type: "wood", color: "#8B4513" });
              worldData.push({ x: x - tileSize, y: y - tileSize, type: "leaf", color: "#228B22" });
              worldData.push({ x: x + tileSize, y: y - tileSize, type: "leaf", color: "#228B22" });
              worldData.push({ x: x, y: y - 2 * tileSize, type: "leaf", color: "#228B22" });
            }
          } else if (row >= bedrockStart) {
            worldData.push({ x: x, y: y, type: "bedrock", color: "#3B3B3B" });
          } else {
            let r = Math.random();
            if (row < mineralStart) {
              if (r < caveChance) continue;
              else if (r < caveChance + waterChance)
                worldData.push({ x: x, y: y, type: "water", color: "#00BFFF" });
              else
                worldData.push({ x: x, y: y, type: "stone", color: "#808080" });
            } else if (row < lavaStart) {
              if (r < caveChance) continue;
              else if (r < caveChance + waterChance)
                worldData.push({ x: x, y: y, type: "water", color: "#00BFFF" });
              else if (r < caveChance + waterChance + oreChance) {
                let ore = oreTypes[Math.floor(Math.random() * oreTypes.length)];
                worldData.push({ x: x, y: y, type: ore.type, color: ore.color });
              } else
                worldData.push({ x: x, y: y, type: "stone", color: "#808080" });
            } else {
              if (r < caveChance) continue;
              else if (r < caveChance + lavaChance)
                worldData.push({ x: x, y: y, type: "lava", color: "#FF4500" });
              else if (r < caveChance + lavaChance + oreChanceDeep) {
                let ore = oreTypes[Math.floor(Math.random() * oreTypes.length)];
                worldData.push({ x: x, y: y, type: ore.type, color: ore.color });
              } else
                worldData.push({ x: x, y: y, type: "deepStone", color: "#808080" });
            }
          }
        }
      }
    }
    
    function findSpawnPoint() {
      let validBlocks = worldData.filter(block => block.type === "grass");
      if (validBlocks.length === 0)
        return { x: tileSize * 2, y: (groundLevel - 1) * tileSize };
      let chosen = validBlocks[Math.floor(Math.random() * validBlocks.length)];
      return { x: chosen.x, y: chosen.y - tileSize };
    }
    
    let cameraX = 0, cameraY = 0;
    function updateCamera() {
      cameraX = player.x - canvas.width / 2;
      cameraY = player.y - canvas.height / 2;
    }
    
    function drawSunMoon() {
      const intensity = (Math.sin(dayTime) + 1) / 2;
      const color = intensity >= 0.5 ? "yellow" : "white";
      const radius = 40;
      let offset = dayTime - Math.PI / 2;
      const centerX = canvas.width / 2;
      const centerY = canvas.height * 0.2;
      const orbitRadius = 200;
      const x = centerX + orbitRadius * Math.cos(offset);
      const y = centerY + orbitRadius * Math.sin(offset);
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }
    
    function drawWorld() {
      for (const block of worldData) {
        if (block.type === "火把") {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x - cameraX, block.y - cameraY, tileSize, tileSize);
          ctx.fillStyle = "rgba(255,165,0,0.2)";
          ctx.fillRect(block.x - cameraX - 5 * tileSize, block.y - cameraY - 5 * tileSize, 11 * tileSize, 11 * tileSize);
        } else {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x - cameraX, block.y - cameraY, tileSize, tileSize);
        }
      }
    }
    
    function drawPlayer() {
      if (player.injured && (Date.now() - player.injuredTime < 500))
        ctx.fillStyle = "red";
      else
        ctx.fillStyle = "#0000FF";
      ctx.fillRect(player.x - cameraX, player.y - cameraY, player.width, player.height);
    }
    
    function updateMobPhysics(mob) {
      mob.vy = mob.vy || 0;
      mob.vy += gravity;
      let newY = mob.y + mob.vy;
      let collision = false;
      if (mob.fallStartY === undefined)
        mob.fallStartY = mob.y;
      for (const block of worldData) {
        if (!["grass", "stone", "wood", "deepStone", "coal", "iron", "gold", "diamond", "bedrock", "火把"].includes(block.type))
          continue;
        if (rectIntersect(mob.x, newY, mob.width, mob.height, block.x, block.y, tileSize, tileSize)) {
          collision = true;
          break;
        }
      }
      if (collision) {
        mob.onGround = true;
        let fallDistance = (mob.y - mob.fallStartY) / tileSize;
        if (fallDistance > 3) {
          mob.hp -= Math.floor(fallDistance) - 3;
        }
        mob.fallStartY = mob.y;
        mob.vy = -10;
      } else {
        mob.onGround = false;
        mob.y = newY;
      }
      if (isMobInLava(mob)) {
        let now = Date.now();
        mob.lastLavaDamageTime = mob.lastLavaDamageTime || now;
        if (now - mob.lastLavaDamageTime >= 1000) {
          mob.hp -= 1;
          mob.lastLavaDamageTime = now;
        }
      }
      if (mob.y > bedrockStart * tileSize) {
        let now = Date.now();
        mob.lastVoidDamageTime = mob.lastVoidDamageTime || now;
        if (now - mob.lastVoidDamageTime >= 1000) {
          mob.hp -= 5;
          mob.lastVoidDamageTime = now;
        }
      }
      // 避免怪物彼此重疊
      for (let other of entities) {
        if (other !== mob && rectIntersect(mob.x, mob.y, mob.width, mob.height, other.x, other.y, other.width, other.height)) {
          if (mob.x < other.x)
            mob.x -= 1;
          else
            mob.x += 1;
        }
      }
    }
    
    function isMobInLava(mob) {
      for (const block of worldData) {
        if (block.type === "lava" && rectIntersect(mob.x, mob.y, mob.width, mob.height, block.x, block.y, tileSize, tileSize))
          return true;
      }
      return false;
    }
    
    function updateEntities() {
      if (gameMode === "peaceful") { entities = []; return; }
      if (!isNight()) { entities = []; return; }
      for (let i = entities.length - 1; i >= 0; i--) {
        let mob = entities[i];
        updateMobPhysics(mob);
        if (mob.type === "zombie") {
          let dx = player.x - mob.x;
          let dy = player.y - mob.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            mob.x += (dx / dist) * 0.5;
            mob.y += (dy / dist) * 0.5;
          }
          if (rectIntersect(mob.x, mob.y, mob.width, mob.height, player.x, player.y, player.width, player.height)) {
            let now = Date.now();
            if (now - mob.lastAttackTime >= 1000) {
              player.health -= 0.5;
              mob.lastAttackTime = now;
              player.injured = true;
              player.injuredTime = now;
            }
          }
        } else if (mob.type === "skeleton") {
          let dx = player.x - mob.x;
          let dy = player.y - mob.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150 && dist > 0) {
            mob.x -= (dx / dist) * 0.4;
            mob.y -= (dy / dist) * 0.4;
          }
          if (dist < 300) {
            let now = Date.now();
            if (now - mob.lastArrowTime >= 1000) {
              mob.lastArrowTime = now;
              let arrowSpeed = 5;
              let adx = player.x - mob.x;
              let ady = player.y - mob.y;
              let aDist = Math.sqrt(adx * adx + ady * ady);
              let arrow = {
                x: mob.x + mob.width / 2,
                y: mob.y + mob.height / 2,
                vx: (adx / aDist) * arrowSpeed,
                vy: (ady / aDist) * arrowSpeed,
                width: tileSize / 2,
                height: tileSize / 2,
                damage: 0.5,
                type: "arrow"
              };
              projectiles.push(arrow);
            }
          }
        } else if (mob.type === "creeper") {
          let dx = player.x - mob.x;
          let dy = player.y - mob.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 50) {
            mob.x += (dx / dist) * 0.3;
            mob.y += (dy / dist) * 0.3;
            mob.countdownStarted = null;
          } else {
            if (!mob.countdownStarted) mob.countdownStarted = Date.now();
            if (Date.now() - mob.countdownStarted >= 3000) {
              // 爆炸效果（此處可擴展摧毀周邊方塊邏輯）
              entities.splice(i, 1);
              continue;
            }
          }
        } else if (mob.type === "spider") {
          let dx = player.x - mob.x;
          let dy = player.y - mob.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            mob.x += (dx / dist) * 0.5;
            mob.y += (dy / dist) * 0.5;
          }
          if (rectIntersect(mob.x, mob.y, mob.width, mob.height, player.x, player.y, player.width, player.height)) {
            let now = Date.now();
            if (now - mob.lastAttackTime >= 1000) {
              player.health -= 0.5;
              mob.lastAttackTime = now;
              player.injured = true;
              player.injuredTime = now;
            }
          }
        }
        if (mob.injured && (Date.now() - mob.injuredTime >= 500))
          mob.injured = false;
        if (mob.hp <= 0) {
          if (mob.type === "zombie")
            addToInventory("rotten", 1);
          else if (mob.type === "skeleton")
            addToInventory("bone", 1);
          entities.splice(i, 1);
        }
      }
    }
    
    function updateProjectiles() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        let proj = projectiles[i];
        proj.x += proj.vx;
        proj.y += proj.vy;
        if (rectIntersect(proj.x, proj.y, proj.width, proj.height,
                          player.x, player.y, player.width, player.height)) {
          player.health -= proj.damage;
          player.injured = true;
          player.injuredTime = Date.now();
          projectiles.splice(i, 1);
          continue;
        }
        if (proj.x < 0 || proj.x > canvas.width + cameraX ||
            proj.y < 0 || proj.y > canvas.height + cameraY)
          projectiles.splice(i, 1);
      }
    }
    
    function drawEntities() {
      for (let mob of entities) {
        if (mob.injured)
          ctx.fillStyle = "red";
        else {
          if (mob.type === "zombie")
            ctx.fillStyle = "#006400";
          else if (mob.type === "skeleton")
            ctx.fillStyle = "#D3D3D3";
          else if (mob.type === "creeper")
            ctx.fillStyle = "#008000";
          else if (mob.type === "spider")
            ctx.fillStyle = "#000000";
          else
            ctx.fillStyle = "#000";
        }
        ctx.fillRect(mob.x - cameraX, mob.y - cameraY, mob.width, mob.height);
      }
    }
    
    function drawProjectiles() {
      for (let proj of projectiles) {
        ctx.fillStyle = "#000000";
        ctx.fillRect(proj.x - cameraX, proj.y - cameraY, proj.width, proj.height);
      }
    }
    
    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
      return !(x2 >= x1 + w1 ||
               x2 + w2 <= x1 ||
               y2 >= y1 + h1 ||
               y2 + h2 <= y1);
    }
    
    function updatePhysics() {
      let newX = player.x + moveDirection * moveSpeed;
      let horizontalCollision = false;
      const tol = 2;
      
      for (const block of worldData) {
        if (!["grass", "stone", "wood", "deepStone", "coal", "iron", "gold", "diamond", "bedrock", "火把"].includes(block.type))
          continue;
        if (player.y + player.height <= block.y || player.y >= block.y + tileSize)
          continue;
        if (block.type === "bedrock") { horizontalCollision = true; break; }
        let leftEdge = Math.max(newX, block.x);
        let rightEdge = Math.min(newX + player.width, block.x + tileSize);
        let overlap = rightEdge - leftEdge;
        if (overlap > tol) { horizontalCollision = true; break; }
      }
      if (!horizontalCollision)
        player.x = newX;
      
      player.vy += gravity;
      let newY = player.y + player.vy;
      let verticalCollision = false;
      for (const block of worldData) {
        if (!["grass", "stone", "wood", "deepStone", "coal", "iron", "gold", "diamond", "bedrock", "火把"].includes(block.type))
          continue;
        if (player.x + player.width <= block.x || player.x >= block.x + tileSize)
          continue;
        if (rectIntersect(player.x, newY, player.width, player.height, block.x, block.y, tileSize, tileSize)) {
          verticalCollision = true;
          if (player.vy > 0) {
            newY = block.y - player.height;
            player.onGround = true;
            player.vy = 0;
          } else if (player.vy < 0) {
            newY = block.y + tileSize;
            player.vy = 0;
          }
          break;
        }
      }
      
      if (isPlayerInWater()) {
        if (!player.waterStartTime) {
          player.waterStartTime = Date.now();
        }
        removeAllTorches();
        player.fallStartY = player.y;
        player.vy *= 0.9;
        let waterDuration = (Date.now() - player.waterStartTime) / 1000;
        if (waterDuration > 10) {
          if (!player.lastWaterDamageTime)
            player.lastWaterDamageTime = Date.now();
          else if (Date.now() - player.lastWaterDamageTime >= 1000) {
            player.health -= 0.5;
            player.lastWaterDamageTime = Date.now();
          }
        }
      } else {
        player.waterStartTime = null;
        player.lastWaterDamageTime = null;
      }
      
      player.y = newY;
      if (!verticalCollision) player.onGround = false;
      
      if (player.onGround && !isPlayerInWater()) {
        if (player.fallStartY !== null) {
          let fallDistance = (player.y - player.fallStartY) / tileSize;
          if (fallDistance > 3)
            player.health -= Math.floor(fallDistance) - 3;
          player.fallStartY = null;
        }
      } else {
        if (player.fallStartY === null)
          player.fallStartY = player.y;
      }
      
      if (isPlayerInLava()) {
        let now = Date.now();
        if (now - lastLavaDamageTime >= 1000) {
          player.health -= 1;
          lastLavaDamageTime = now;
        }
      }
      
      if (player.y > bedrockStart * tileSize) {
        let now = Date.now();
        if (now - lastVoidDamageTime >= 1000) {
          player.health -= 10;
          lastVoidDamageTime = now;
        }
      }
    }
    
    function isPlayerInWater() {
      for (const block of worldData) {
        if (block.type === "water" && rectIntersect(player.x, player.y, player.width, player.height, block.x, block.y, tileSize, tileSize))
          return true;
      }
      return false;
    }
    
    function isPlayerInLava() {
      for (const block of worldData) {
        if (block.type === "lava" && rectIntersect(player.x, player.y, player.width, player.height, block.x, block.y, tileSize, tileSize))
          return true;
      }
      return false;
    }
    
    function updateInterface() {
      document.getElementById("hpDisplay").innerText = "HP: " + player.health;
    }
    
    /* —— 庫存系統 —— */
    function addToInventory(item, count) {
      inventory[item] = (inventory[item] || 0) + count;
      updateInventoryUI();
    }
    
    function updateInventoryUI() {
      const container = document.getElementById("inventoryUI");
      container.innerHTML = "";
      for (let item in inventory) {
        if (inventory[item] <= 0) continue;
        const btn = document.createElement("button");
        btn.innerText = item + " x" + inventory[item];
        switch (item) {
          case "wood": btn.style.backgroundColor = "#8B4513"; break;
          case "stone": btn.style.backgroundColor = "#808080"; break;
          case "iron": btn.style.backgroundColor = "#FFF8E1"; break;
          case "gold": btn.style.backgroundColor = "#FFD700"; break;
          case "diamond": btn.style.backgroundColor = "#00FFFF"; break;
          case "grass": btn.style.backgroundColor = "#00FF00"; break;
          case "coal": btn.style.backgroundColor = "#2F4F4F"; break;
          default: btn.style.backgroundColor = "#fff";
        }
        if (collectibleTypes.includes(item))
          btn.onclick = () => { selectBlock(item); };
        container.appendChild(btn);
      }
    }
    
    let selectedBlock = null;
    function selectBlock(material) {
      selectedBlock = material;
      console.log("選取素材: " + material);
    }
    
    /* —— 物品庫存系統 —— */
    function addToItemInventory(item, count) {
      itemInventory[item] = (itemInventory[item] || 0) + count;
      updateItemInventoryUI();
    }
    
    function updateItemInventoryUI() {
      const container = document.getElementById("iteminventory");
      container.innerHTML = "";
      for (let item in itemInventory) {
        if (itemInventory[item] <= 0) continue;
        const btn = document.createElement("button");
        btn.innerText = item + " x" + itemInventory[item];
        switch (item) {
          case "木劍": btn.style.backgroundColor = "#CD853F"; break;
          case "石劍": btn.style.backgroundColor = "#A9A9A9"; break;
          case "鐵劍": btn.style.backgroundColor = "#D3D3D3"; break;
          case "黃金劍": btn.style.backgroundColor = "#FFD700"; break;
          case "鑽石劍": btn.style.backgroundColor = "#00FFFF"; break;
          case "木鎬": btn.style.backgroundColor = "#DEB887"; break;
          case "石鎬": btn.style.backgroundColor = "#C0C0C0"; break;
          case "鐵鎬": btn.style.backgroundColor = "#D3D3D3"; break;
          case "黃金鎬": btn.style.backgroundColor = "#FFD700"; break;
          case "鑽石鎬": btn.style.backgroundColor = "#00FFFF"; break;
          case "蘋果":
            btn.style.backgroundColor = "#FF6347";
            btn.onclick = () => {
              if (player.health < 10) {
                player.health += 5;
                if (player.health > 10) player.health = 10;
                itemInventory["蘋果"]--;
                if (itemInventory["蘋果"] <= 0) delete itemInventory["蘋果"];
                updateItemInventoryUI();
                updateInterface();
              }
            };
            break;
          case "鐵桶": btn.style.backgroundColor = "#FFFFFF"; break;
          case "火把":
            btn.style.backgroundColor = "#F5DEB3";
            btn.onclick = () => { activateTorchFromInventory(); };
            break;
          default: btn.style.backgroundColor = "#fff";
        }
        if (!btn.onclick)
          btn.onclick = () => { };
        container.appendChild(btn);
      }
    }
    
    /* —— 合成系統 —— */
    function openCrafting() {
      const container = document.getElementById("craftingOptions");
      container.innerHTML = "";
      recipes.forEach(recipe => {
        let reqText = "";
        for (let mat in recipe.materials)
          reqText += mat + " (x" + recipe.materials[mat] + ") ";
        const btn = document.createElement("button");
        btn.innerText = recipe.name + "\n需要: " + reqText;
        let canCraft = true;
        for (let mat in recipe.materials) {
          if ((inventory[mat] || 0) < recipe.materials[mat]) {
            canCraft = false;
            break;
          }
        }
        btn.disabled = !canCraft;
        btn.onclick = () => { craftItem(recipe); };
        container.appendChild(btn);
      });
      document.getElementById("craftingScreen").style.display = "block";
    }
    
    function closeCrafting() {
      document.getElementById("craftingScreen").style.display = "none";
    }
    
    function craftItem(recipe) {
      for (let mat in recipe.materials) {
        if ((inventory[mat] || 0) < recipe.materials[mat])
          return;
      }
      for (let mat in recipe.materials) {
        inventory[mat] -= recipe.materials[mat];
        if (inventory[mat] <= 0)
          delete inventory[mat];
      }
      if (recipe.name === "火把") {
        addToItemInventory("火把", 1);
      } else if (recipe.isTool) {
        if (recipe.toolLevel > player.toolLevel)
          player.toolLevel = recipe.toolLevel;
        if (recipe.type === "sword" || recipe.type === "pickaxe" || recipe.type === "bucket") {
          addToItemInventory(recipe.name, 1);
          if (recipe.type === "sword") {
            if (recipe.name === "木劍" || recipe.name === "黃金劍")
              playerWeaponBonus = Math.max(playerWeaponBonus, 1);
            else if (recipe.name === "石劍")
              playerWeaponBonus = Math.max(playerWeaponBonus, 2);
            else if (recipe.name === "鐵劍")
              playerWeaponBonus = Math.max(playerWeaponBonus, 3);
            else if (recipe.name === "鑽石劍")
              playerWeaponBonus = Math.max(playerWeaponBonus, 4);
          }
          console.log("獲得 " + recipe.name + "，工具等級提升到 " + player.toolLevel);
        } else {
          addToInventory(recipe.name, 1);
        }
      } else {
        addToInventory(recipe.name, 1);
      }
      updateInventoryUI();
      updateItemInventoryUI();
      closeCrafting();
    }
    
    /* —— 破壞與放置 —— */
    function destroyBlockDir(direction) {
      let grid = getPlayerGrid();
      if (direction === "up") grid.row--;
      if (direction === "down") grid.row++;
      if (direction === "left") grid.col--;
      if (direction === "right") grid.col++;
      let blockX = grid.col * tileSize;
      let blockY = grid.row * tileSize;
      for (let i = 0; i < worldData.length; i++) {
        if (worldData[i].x === blockX && worldData[i].y === blockY) {
          if (worldData[i].type === "bedrock") {
            console.log("基岩無法破壞");
            return;
          }
          if (worldData[i].type === "火把") {
            worldData.splice(i, 1);
            addToInventory("wood", 1);
            return;
          }
          if (worldData[i].type === "water" || worldData[i].type === "lava") {
            if (!itemInventory["鐵桶"] || itemInventory["鐵桶"] <= 0) {
              console.log("需要鐵桶才能破壞水或熔岩！");
              return;
            } else {
              addToInventory(worldData[i].type, 1);
              worldData.splice(i, 1);
              return;
            }
          }
          if (worldData[i].type === "leaf") {
            if (Math.random() < 0.5) {
              addToItemInventory("蘋果", 1);
            }
          }
          const req = blockRequirements[worldData[i].type];
          if (req !== undefined && player.toolLevel < req) {
            console.log("工具等級不足，無法破壞 " + worldData[i].type);
            return;
          }
          if (collectibleTypes.includes(worldData[i].type)) {
            addToInventory(worldData[i].type, 1);
          }
          worldData.splice(i, 1);
          break;
        }
      }
    }
    
    function placeBlockDir(direction) {
      let grid = getPlayerGrid();
      if (direction === "up") grid.row--;
      if (direction === "down") grid.row++;
      if (direction === "left") grid.col--;
      if (direction === "right") grid.col++;
      let blockX = grid.col * tileSize;
      let blockY = grid.row * tileSize;
      if (!worldData.some(b => b.x === blockX && b.y === blockY)) {
        if (selectedBlock && inventory[selectedBlock] > 0) {
          let type = selectedBlock;
          let color = "#fff";
          switch(selectedBlock) {
            case "wood": color = "#8B4513"; break;
            case "stone": color = "#808080"; break;
            case "iron": color = "#FFF8E1"; break;
            case "gold": color = "#FFD700"; break;
            case "diamond": color = "#00FFFF"; break;
            case "grass": color = "#00FF00"; break;
            default: break;
          }
          worldData.push({ x: blockX, y: blockY, type: type, color: color });
          inventory[selectedBlock]--;
          if (inventory[selectedBlock] <= 0) {
            delete inventory[selectedBlock];
            selectedBlock = null;
          }
          updateInventoryUI();
        } else {
          console.log("沒有足夠的素材放置！");
        }
      }
    }
    
    function getPlayerGrid() {
      const col = Math.floor((player.x + player.width / 2) / tileSize);
      const row = Math.floor((player.y + player.height / 2) / tileSize);
      return { col, row };
    }
    
    function playerAttack() {
      let centerX = player.x + player.width / 2;
      let centerY = player.y + player.height / 2;
      let attackRange = 9 * tileSize;
      let attackDamage = 0.5 + playerWeaponBonus;
      for (let i = entities.length - 1; i >= 0; i--) {
        let mob = entities[i];
        if (rectIntersect(centerX - attackRange / 2, centerY - attackRange / 2, attackRange, attackRange,
                          mob.x, mob.y, mob.width, mob.height)) {
          mob.hp -= attackDamage;
          mob.injured = true;
          mob.injuredTime = Date.now();
          if (mob.hp <= 0) {
            if (mob.type === "zombie")
              addToInventory("rotten", 1);
            else if (mob.type === "skeleton")
              addToInventory("bone", 1);
            entities.splice(i, 1);
          }
        }
      }
    }
    
    function spawnMobs() {
      if (gameMode === "peaceful") return;
      if (isNight() && entities.length < 5 && Math.random() < 0.005) {
        let mobType;
        let r = Math.random();
        if (r < 0.33) mobType = "zombie";
        else if (r < 0.66) mobType = "skeleton";
        else if (r < 0.83) mobType = "creeper";
        else mobType = "spider";
        let spawnX = player.x + (Math.random() * 500 - 250);
        let spawnY = player.y;
        let mob = {
          x: spawnX,
          y: spawnY,
          width: tileSize,
          height: tileSize,
          type: mobType,
          hp: (mobType === "spider") ? 5 : 10,
          speed: (mobType === "zombie") ? 0.5 : (mobType === "skeleton") ? 0.4 : (mobType === "creeper") ? 0.3 : 0.5,
          injured: false,
          injuredTime: 0,
          vy: 0
        };
        if (mobType === "zombie") mob.lastAttackTime = 0;
        if (mobType === "skeleton") mob.lastArrowTime = 0;
        if (mobType === "creeper") mob.countdownStarted = null;
        if (mobType === "spider") mob.lastAttackTime = 0;
        entities.push(mob);
      }
    }
    
    function gameLoop() {
      updateBackground();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      drawSunMoon();
      ctx.restore();
      
      updatePhysics();
      updateCamera();
      drawWorld();
      
      spawnMobs();
      updateEntities();
      updateProjectiles();
      drawEntities();
      drawProjectiles();
      
      drawPlayer();
      updateInterface();
      
      if (player.health <= 0) {
        gameOver = true;
        showDeathScreen();
        return;
      }
      requestAnimationFrame(gameLoop);
    }
    
    function showDeathScreen() {
      document.getElementById("deathScreen").style.display = "flex";
    }
    
    function goToHomePage() {
      gameOver = true;
      document.getElementById("startScreen").style.display = "flex";
    }
    
    function restartGame() {
      player.x = tileSize * 2;
      player.y = (groundLevel - 1) * tileSize;
      player.vy = 0;
      player.health = 10;
      player.fallStartY = null;
      player.toolLevel = -1; // 重置為空手
      player.waterStartTime = null;
      player.lastWaterDamageTime = null;
      gameOver = false;
      player.injured = false;
      document.getElementById("deathScreen").style.display = "none";
      generateWorld();
      let spawn = findSpawnPoint();
      player.x = spawn.x;
      player.y = spawn.y;
      lastLavaDamageTime = Date.now();
      lastVoidDamageTime = Date.now();
      inventory = {};
      updateInventoryUI();
      itemInventory = {};
      updateItemInventoryUI();
      entities = [];
      projectiles = [];
      startTime = performance.now();
      gameLoop();
    }
    
    function moveLeft() { moveDirection = -1; }
    function moveRight() { moveDirection = 1; }
    function stopMoving() { moveDirection = 0; }
    function jump() {
      if (player.onGround || isPlayerInWater()){
        player.vy = jumpVelocity;
        player.onGround = false;
      }
    }
    
    function startAdventure() {
      gameMode = "adventure";
      document.getElementById("startScreen").style.display = "none";
      restartGame();
    }
    
    function startPeaceful() {
      gameMode = "peaceful";
      document.getElementById("startScreen").style.display = "none";
      restartGame();
    }
    
    window.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") moveLeft();
      if (e.key === "ArrowRight") moveRight();
      if (e.key === " " || e.key === "ArrowUp") jump();
    });
    window.addEventListener("keyup", e => {
      if (e.key === "ArrowLeft" || e.key === "ArrowRight") stopMoving();
    });
    
    function activateTorchFromInventory() {
      let grid = getPlayerGrid();
      let blockX = grid.col * tileSize;
      let blockY = grid.row * tileSize;
      if (worldData.some(b => b.x === blockX && b.y === blockY)) {
        console.log("此處已有方塊，無法放置火把！");
        return;
      }
      worldData.push({
        x: blockX,
        y: blockY,
        type: "火把",
        color: "#F5DEB3"
      });
      itemInventory["火把"]--;
      if (itemInventory["火把"] <= 0) delete itemInventory["火把"];
      updateItemInventoryUI();
      
      const torchDuration = 60000;
      const interval = 500;
      const startTimeTorch = Date.now();
      const torchInterval = setInterval(() => {
        let range = 5 * tileSize;
        entities = entities.filter(mob => {
          if (mob.x >= blockX - range && mob.x <= blockX + range &&
              mob.y >= blockY - range && mob.y <= blockY + range) {
            return false;
          }
          return true;
        });
        if (Date.now() - startTimeTorch >= torchDuration) {
          clearInterval(torchInterval);
          removeTorch(blockX, blockY);
        }
      }, interval);
    }
    

    function removeTorch(x, y) {
      for (let i = 0; i < worldData.length; i++) {
        if (worldData[i].type === "火把" && worldData[i].x === x && worldData[i].y === y) {
          worldData.splice(i, 1);
          addToInventory("wood", 1);
          break;
        }
      }
    }
    
    function removeAllTorches() {
      let removedCount = 0;
      worldData = worldData.filter(block => {
        if (block.type === "火把") {
          removedCount++;
          return false;
        }
        return true;
      });
      if (removedCount > 0) {
        addToInventory("wood", removedCount);
      }
    }
    
    function getPlayerGrid() {
      const col = Math.floor((player.x + player.width / 2) / tileSize);
      const row = Math.floor((player.y + player.height / 2) / tileSize);
      return { col, row };
    }
  </script>
</body>
</html>

